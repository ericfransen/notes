#!/bin/bash

debug_log() {
    if [ "$DEBUG_MODE" = "true" ]; then
        echo "DEBUG: $@"
    fi
}

extract_title_from_note() {
    local note_string="$1"
    # Get the first 7 words of the note string
    local first_seven_words=$(echo "$note_string" | cut -d' ' -f1-7)

    # Check if these first 7 words contain a colon
    if [[ "$first_seven_words" == *":"* ]]; then
        # If yes, the title is the first 5 words of the original string
        echo "$note_string" | cut -d' ' -f1-5
    else
        # If no colon in the first 7 words, return empty
        echo ""
    fi
}

# --- Find Project Root ---
SOURCE=${BASH_SOURCE[0]}
while [ -L "$SOURCE" ]; do
  DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
  SOURCE=$(readlink "$SOURCE")
  [[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE
done
SCRIPT_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
PROJECT_ROOT="$SCRIPT_DIR/.."
CONFIG_FILE="$PROJECT_ROOT/config.sh"

# --- Source Config ---
if [ ! -f "$CONFIG_FILE" ]; then echo "Config not found. Run 'bash scripts/setup.sh'" >&2; exit 1; fi
source "$CONFIG_FILE"

# --- Argument Parsing ---
DEBUG_MODE="false"
OPEN_IN_VAULT="false"
KEYWORDS=()
METADATA_YAML=""
OTHER_ARGS=()
CUSTOM_TITLE=""
PROCESSED_DIR=""
USE_FZF_TEMPLATE=false
TEMPLATE_ALIAS=""

while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -debug)
      DEBUG_MODE="true"
      shift
      ;;
    -v)
      OPEN_IN_VAULT="true"
      shift
      ;;
    -template)
      USE_FZF_TEMPLATE=true
      shift
      ;;
    --title)
      if [ -n "$CUSTOM_TITLE" ]; then
        echo "Error: Only one title can be provided." >&2
        exit 1
      fi
      CUSTOM_TITLE="$2"
      shift; shift
      ;;
    _*)
      if [ -n "$CUSTOM_TITLE" ]; then
        echo "Error: Only one title can be provided." >&2
        exit 1
      fi
      CUSTOM_TITLE="${1#_}"
      shift
      ;;
    --*)
      key="${1#--}"
      if [[ -n "$2" ]] && [[ "$2" != --* ]] && [[ "$2" != '@'* ]] && [[ "$2" != '+'* ]]; then
        value="$2"
        METADATA_YAML+="${key}: \"${value}\"\n"
        shift; shift
      else
        METADATA_YAML+="${key}: true\n"
        shift
      fi
      ;;
    +*)
      KEYWORDS+=("$(echo "${1#+}" | tr '[:upper:]' '[:lower:]')")
      shift
      ;;
    @*)
      PROCESSED_DIR="${1#@}"
      shift
      ;;
    "%")
      USE_FZF_TEMPLATE=true
      shift
      ;;
    %*)
      TEMPLATE_ALIAS="${1#%}"
      shift
      ;;
    *)
      OTHER_ARGS+=("$1")
      shift
      ;;
  esac
done

if [ "$DEBUG_MODE" = "true" ]; then
    set -x
fi

# The first utility command (e.g., -vault, -debug) is also captured here
COMMAND="" # Initialize COMMAND here

while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -v)
      OPEN_IN_VAULT="true"
      shift
      ;;
    -template)
      USE_FZF_TEMPLATE=true
      shift
      ;;
    --title)
      if [ -n "$CUSTOM_TITLE" ]; then
        echo "Error: Only one title can be provided." >&2
        exit 1
      fi
      CUSTOM_TITLE="$2"
      shift; shift
      ;;
    _*)
      if [ -n "$CUSTOM_TITLE" ]; then
        echo "Error: Only one title can be provided." >&2
        exit 1
      fi
      CUSTOM_TITLE="${1#_}"
      shift
      ;;
    --*)
      key="${1#--}"
      if [[ -n "$2" ]] && [[ "$2" != --* ]] && [[ "$2" != '@'* ]] && [[ "$2" != '+'* ]]; then
        value="$2"
        METADATA_YAML+="${key}: \"${value}\"\n"
        shift; shift
      else
        METADATA_YAML+="${key}: true\n"
        shift
      fi
      ;;
    +*)
      KEYWORDS+=("$(echo "${1#+}" | tr '[:upper:]' '[:lower:]')")
      shift
      ;;
    @*)
      PROCESSED_DIR="${1#@}"
      shift
      ;;
    "%")
      USE_FZF_TEMPLATE=true
      shift
      ;;
    %*)
      TEMPLATE_ALIAS="${1#%}"
      shift
      ;;
    -daily|-vault|-debug|-git-setup|-sync-status|-code|-obsidian|-rename-all-untitled|-yesterday|-cmd)
      COMMAND="${1#-}" # Set COMMAND directly for known commands
      shift
      ;;
    *)
      OTHER_ARGS+=("$1")
      shift
      ;;
  esac
done

# If COMMAND was not set by a specific flag, and there are other args, and the first other arg starts with '-', it's a command.
if [ -z "$COMMAND" ] && [[ "${OTHER_ARGS[0]}" == -* ]]; then
    COMMAND="${OTHER_ARGS[0]#-}"
    # Remove the command from OTHER_ARGS so it's not treated as NOTE_STRING
    OTHER_ARGS=("${OTHER_ARGS[@]:1}")
fi

# The first non-flag argument that is not a command is the note string for atomic notes
NOTE_STRING="${OTHER_ARGS[0]}"

# --- For all other commands, source the config ---
# This line is redundant and should be removed as config is sourced at the beginning.
# if [ ! -f "$CONFIG_FILE" ]; then echo "Config not found. Run 'bash scripts/setup.sh'" >&2; exit 1; fi
# source "$CONFIG_FILE"

# --- Command Routing ---
# Allow for commands with a leading hyphen
# This is now handled in the argument parsing, so this block is redundant.
# if [[ "$COMMAND" == -* ]]; then
#     COMMAND="${COMMAND#-}"
# fi

# --- Template Selection Logic ---
# Default to the standard note template
TEMPLATE_PATH="$PROJECT_ROOT/$NOTE_TEMPLATE_PATH"

if [ "$USE_FZF_TEMPLATE" = true ] || [ "$COMMAND" == "daily" ] || [ -n "$TEMPLATE_ALIAS" ]; then
    if [ "$COMMAND" == "daily" ]; then
        TEMPLATE_ALIAS="daily"
    fi

    if [ -n "$TEMPLATE_ALIAS" ]; then
        echo "Searching for [$TEMPLATE_ALIAS] template..."
        while read -r alias path; do
        debug_log "Parsing template mapping - alias: '$alias', path: '$path'"
        if [ -n "$alias" ] && [ "$alias" == "$TEMPLATE_ALIAS" ]; then
                TEMPLATE_PATH="$PROJECT_ROOT/$path"
                break
            fi
        done <<< "$TEMPLATE_MAPPINGS"
    fi

    if [ ! -f "$TEMPLATE_PATH" ]; then
        if [ -n "$TEMPLATE_ALIAS" ]; then
            echo "Warning: Template alias '%$TEMPLATE_ALIAS' not found in config.sh." >&2
        fi
        if ! command -v fzf &> /dev/null; then
            echo "fzf is not installed. Please install it to use the template selection feature." >&2
            echo "See: https://github.com/junegunn/fzf#installation" >&2
            exit 1
        fi
        SELECTED_TEMPLATE_NAME=$(find "$PROJECT_ROOT/templates" -type f -name "*.md" | sed "s|$PROJECT_ROOT/templates/||" | fzf --prompt="Select a template: " --height=20 --border --color=dark)
        if [ -n "$SELECTED_TEMPLATE_NAME" ]; then
            TEMPLATE_PATH="$PROJECT_ROOT/templates/$SELECTED_TEMPLATE_NAME"
        else
            echo "No template selected. Aborting." >&2
            exit 1
        fi
    fi
    echo "Using [$(basename "$TEMPLATE_PATH" .md)] template from _notes/$(echo "$TEMPLATE_PATH" | sed "s|$PROJECT_ROOT/||")"
fi

if [[ "$COMMAND" == "cmd" ]]; then
    cat "$PROJECT_ROOT/COMMANDS.md"
    exit 0
fi

if [[ "$COMMAND" == "vault" ]]; then
    if [ -n "$VAULT_PATH" ]; then
        echo "Your vault is currently set to: $VAULT_PATH"
        read -p "Do you want to change it? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            read -p "Enter the new path to your vault: " new_vault_path
            # Update the config file
            sed -i '' "s|VAULT_PATH=.*|VAULT_PATH=\"$new_vault_path\"|" "$CONFIG_FILE"
            echo "Vault path updated to: $new_vault_path"
        else
            read -p "Do you want to open the vault? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                "$EDITOR_CMD" "$VAULT_PATH"
            fi
        fi
    else
        echo "Your vault is not yet configured."
        read -p "Enter the path to your vault: " new_vault_path
        # Update the config file
        echo "VAULT_PATH=\"$new_vault_path\"" >> "$CONFIG_FILE"
        echo "Vault path set to: $new_vault_path"
    fi
    exit 0
fi

# --- Handle all other utility commands ---
case "$COMMAND" in
    daily)
        TODAY_DATE=$(date +'%y-%m-%d')
        # Search for any daily note for today, regardless of the title part
        EXISTING_DAILY_NOTE=$(find "${VAULT_PATH}/${DAILY_DIR}" -name "${TODAY_DATE}_*.md" -print -quit)

        if [ -n "$EXISTING_DAILY_NOTE" ]; then
            echo "Found existing daily note for today: $EXISTING_DAILY_NOTE"
            echo "Opening for editing..."
            # Use the same opening logic as the main note creation
            if [[ "$OPEN_IN_VAULT" == "true" ]]; then
                "$EDITOR_CMD" "$VAULT_PATH" --goto "$EXISTING_DAILY_NOTE":1
            else
                "$EDITOR_CMD" -g "$EXISTING_DAILY_NOTE":1
            fi
            exit 0
        fi
        # If no existing note, fall through to create a new one
        ;;
    git-setup)
        if [ ! -d "$VAULT_PATH/.git" ]; then
            git init "$VAULT_PATH"
            echo "Git repository initialized in '$VAULT_PATH'."
        else
            echo "Git repository already exists in '$VAULT_PATH'."
        fi
        exit 0
        ;;
    sync-status)
        (cd "$VAULT_PATH" && git status)
        exit 0
        ;;
    code)
        "$EDITOR_CMD" "$VAULT_PATH"
        exit 0
        ;;
    obsidian)
        open "obsidian://vault/${VAULT_NAME}"
        exit 0
        ;;
    rename-all-untitled)
        "$PROJECT_ROOT/scripts/note-sync" --rename-all
        exit 0
        ;;
    yesterday)
        YESTERDAY=$(date -v -1d +'%y-%m-%d')
        YESTERDAY_NOTE=$(find "$VAULT_PATH/$DAILY_DIR" -name "*$YESTERDAY*.md" -print -quit)

        if [ -n "$YESTERDAY_NOTE" ]; then
            "$EDITOR_CMD" "$YESTERDAY_NOTE"
        else
            LAST_DAILY_NOTE=$(find "$VAULT_PATH/$DAILY_DIR" -name "*.md" -print | sort -r | head -n 1)
            if [ -n "$LAST_DAILY_NOTE" ]; then
                echo "No daily note was captured for yesterday, opening last daily note from $(basename "$LAST_DAILY_NOTE" .md)..."
                "$EDITOR_CMD" "$LAST_DAILY_NOTE"
            else
                echo "No daily notes found."
            fi
        fi
        exit 0
        ;;
esac

# --- Main Note Creation Logic ---
if [ -z "$VAULT_PATH" ]; then echo "VAULT_PATH is not set. Please run 'note -vault'." >&2; exit 1; fi

MODE="editor"
# Atomic mode is only triggered if a note string is provided.
if [[ -n "$NOTE_STRING" ]]; then
    MODE="atomic"
fi

# Determine the subdirectory for the note
SUBDIR_FROM_TEMPLATE=""
if [ -n "$TEMPLATE_ALIAS" ]; then
    while read -r alias output_dir; do
        if [ -n "$alias" ] && [ "$alias" == "$TEMPLATE_ALIAS" ]; then
            SUBDIR_FROM_TEMPLATE="$output_dir"
            break
        fi
    done <<< "$TEMPLATE_OUTPUT_DIRS"
fi

if [ -n "$TEMPLATE_ALIAS" ] && [ -z "$SUBDIR_FROM_TEMPLATE" ]; then
    echo "Warning: No output directory mapping found for template alias '$TEMPLATE_ALIAS'. Using default inbox." >&2
fi

if [ -n "$SUBDIR_FROM_TEMPLATE" ]; then
    SUBDIR="$SUBDIR_FROM_TEMPLATE"
    STATUS="templated" # New status for notes from templates with custom output dirs
elif [[ -n "$PROCESSED_DIR" ]]; then
    SUBDIR="$PROCESSED_DIR"
    STATUS="processed"
else
    SUBDIR="00__Inbox"
    STATUS="inbox"
fi

to_kebab_case() { echo "$1" | cut -d' ' -f1-5 | iconv -t ascii//TRANSLIT | sed -E 's/[^a-zA-Z0-9]+/-/g' | sed -E 's/^-+|-+$//g' | tr '[:upper:]' '[:lower:]'; }

TIMESTAMP=$(date +'%y-%m-%d %H:%M:%S'); FILE_TIMESTAMP=$(date +'%y-%m-%d__%H-%M')
DAY_OF_WEEK=$(date +'%A') # Get the full weekday name
DAY_ABBREVIATION=$(date +'%a' | tr '[:lower:]' '[:upper:]') # Get 3-letter day abbreviation
TITLE=""; BODY=""; KEYWORDS_STRING=""
if [ ${#KEYWORDS[@]} -gt 0 ]; then KEYWORDS_STRING=$(IFS=,; echo "${KEYWORDS[*]}"); fi
if [ "$COMMAND" == "daily" ]; then
    TITLE="${DAY_ABBREVIATION}_daily"
elif [ "$TEMPLATE_ALIAS" == "meeting" ]; then # Set title for meeting notes
    TITLE="meeting"
    TITLE=$(echo "$NOTE_STRING" | cut -c 1-80)
    BODY="$NOTE_STRING"
else
    TITLE="untitled" # <--- This is the culprit
    BODY=""
fi

if [[ -n "$CUSTOM_TITLE" ]]; then
    TITLE="$CUSTOM_TITLE"
elif [[ -n "$NOTE_STRING" ]]; then
    # If no custom title, try to extract from note string
    EXTRACTED_TITLE=$(extract_title_from_note "$NOTE_STRING")
    if [[ -n "$EXTRACTED_TITLE" ]]; then
        TITLE="$EXTRACTED_TITLE"
        # The rest of the string becomes the body
        BODY="${NOTE_STRING#*: }"
    else
        TITLE="untitled"
        BODY="$NOTE_STRING"
    fi
fi

KEBAB_TITLE=$(to_kebab_case "$TITLE")
FILENAME_PART=""

if [ "$COMMAND" == "daily" ]; then
    FILENAME_PART="${DAY_ABBREVIATION}_daily"
elif [ "$TEMPLATE_ALIAS" == "meeting" ]; then
    FILENAME_PART="mtg"
fi

if [ -n "$FILENAME_PART" ]; then
    if [ "$COMMAND" == "daily" ]; then
        FILENAME="${FILE_TIMESTAMP}__${FILENAME_PART}.md"
    elif [ -n "$KEBAB_TITLE" ] && [ "$KEBAB_TITLE" != "$(to_kebab_case "$FILENAME_PART")" ]; then
        FILENAME="${FILE_TIMESTAMP}__${FILENAME_PART}-${KEBAB_TITLE}.md"
    else
        FILENAME="${FILE_TIMESTAMP}__${FILENAME_PART}.md"
    fi
else
    FILENAME="${FILE_TIMESTAMP}__${KEBAB_TITLE}.md"
fi
TARGET_DIR="${VAULT_PATH}/${SUBDIR}"; FILEPATH="${TARGET_DIR}/${FILENAME}"; mkdir -p "$TARGET_DIR"

# --- Template Selection Logic ---
# Default to the standard note template
TEMPLATE_PATH="$PROJECT_ROOT/$NOTE_TEMPLATE_PATH"

# If -template is used, launch fzf
if [ "$USE_FZF_TEMPLATE" = true ]; then
    if ! command -v fzf &> /dev/null; then
        echo "fzf is not installed. Please install it to use the template selection feature." >&2
        echo "See: https://github.com/junegunn/fzf#installation" >&2
        exit 1
    fi
    SELECTED_TEMPLATE_NAME=$(find "$PROJECT_ROOT/templates" -type f -name "*.md" | sed "s|$PROJECT_ROOT/templates/||" | fzf --prompt="Select a template: " --height=20 --border --color=dark)
    if [ -n "$SELECTED_TEMPLATE_NAME" ]; then
        TEMPLATE_PATH="$PROJECT_ROOT/templates/$SELECTED_TEMPLATE_NAME"
    else
        echo "No template selected. Aborting." >&2
        exit 1
    fi
fi

# If %template-alias is used, look it up in the config
if [ -n "$TEMPLATE_ALIAS" ]; then
    while read -r alias path; do
        if [ -n "$alias" ] && [ "$alias" == "$TEMPLATE_ALIAS" ]; then
            TEMPLATE_PATH="$PROJECT_ROOT/$path"
            break
        fi
    done <<< "$TEMPLATE_MAPPINGS"

    if [ ! -f "$TEMPLATE_PATH" ]; then
        echo "Warning: Template alias '%$TEMPLATE_ALIAS' not found in config.sh." >&2
        if ! command -v fzf &> /dev/null; then
            echo "fzf is not installed. Please install it to use the template selection feature." >&2
            echo "See: https://github.com/junegunn/fzf#installation" >&2
            exit 1
        fi
        SELECTED_TEMPLATE_NAME=$(find "$PROJECT_ROOT/templates" -type f -name "*.md" | sed "s|$PROJECT_ROOT/templates/||" | fzf --prompt="Select a template: " --height=20 --border --color=dark)
        if [ -n "$SELECTED_TEMPLATE_NAME" ]; then
            TEMPLATE_PATH="$PROJECT_ROOT/templates/$SELECTED_TEMPLATE_NAME"
        else
            echo "No template selected. Aborting." >&2
            exit 1
        fi
    fi
fi

if [ ! -f "$TEMPLATE_PATH" ]; then echo "Warning: Template not found." >&2; touch "$FILEPATH"; else
    # echo "timestamp: $TIMESTAMP"
    # echo "title: $TITLE"
    # echo "keywords: $KEYWORDS_STRING"
    # echo "body: $BODY"
    # echo "meta: $METADATA_YAML"
    # echo "status: $STATUS"
    export BODY=$(printf "%b" "$BODY")
    CONTENT=$(cat "$TEMPLATE_PATH" | awk -v ts="$TIMESTAMP" -v ti="$TITLE" -v kw="$KEYWORDS_STRING" -v meta="$METADATA_YAML" -v status="$STATUS" -v day="$DAY_OF_WEEK" -v folder="$SUBDIR" '{
        gsub(/<% timestamp %>/, ts);
        gsub(/<% title %>/, ti);
        gsub(/<% keywords %>/, kw);
        gsub(/<% body %>/, ENVIRON["BODY"]);
        gsub(/<% metadata %>/, meta);
        gsub(/<% status %>/, status);
        gsub(/<% day %>/, day);
        gsub(/<% folder %>/, folder);
        print;
    }')
    echo "$CONTENT" > "$FILEPATH"
fi

body_line_number=$(echo "$CONTENT" | grep -n "## Body" | cut -d: -f1)
cursor_line_number=$((body_line_number + 1))

echo "Note created: $FILEPATH"
debug_log "MODE is $MODE"
if [ "$MODE" == "editor" ]; then
    echo "Opening for editing..."
    if [[ "$OPEN_IN_VAULT" == "true" ]]; then 
        # echo "Executing: $EDITOR_CMD $VAULT_PATH --goto $FILEPATH:$cursor_line_number"
        debug_log "Executing command: \"$EDITOR_CMD\" \"$VAULT_PATH\" --goto \"$FILEPATH\":$cursor_line_number"
        "$EDITOR_CMD" "$VAULT_PATH" --goto "$FILEPATH":$cursor_line_number; 
    else 
        debug_log "Executing command: \"$EDITOR_CMD\" -g \"$FILEPATH\":$cursor_line_number"
        "$EDITOR_CMD" -g "$FILEPATH":$cursor_line_number; 
    fi
fi