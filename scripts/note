#!/bin/bash

debug_log() {
    if [ "$DEBUG_MODE" = "true" ]; then
        echo "DEBUG: $@"
    fi
}

extract_title_from_note() {
    local note_string="$1"
    # Get the first line of the note string
    local first_line=$(echo "$note_string" | head -n 1)

    # Check if the first line contains a colon
    if [[ "$first_line" == *":"* ]]; then
        # Extract the part before the colon from the first line
        echo "${first_line%%:*}"
    else
        # If no colon in the first line, return empty
        echo ""
    fi
}

# --- Find Project Root ---
SOURCE=${BASH_SOURCE[0]}
while [ -L "$SOURCE" ]; do
  DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
  SOURCE=$(readlink "$SOURCE")
  [[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE
done
SCRIPT_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
PROJECT_ROOT="$SCRIPT_DIR/.."
CONFIG_FILE="$PROJECT_ROOT/config.sh"

# --- Source Config ---
if [ ! -f "$CONFIG_FILE" ]; then echo "Config not found. Run 'bash scripts/setup.sh'" >&2; exit 1; fi
source "$CONFIG_FILE"

# --- Argument Parsing ---
DEBUG_MODE="false"
OPEN_IN_VAULT="false"
KEYWORDS=()
METADATA_YAML=""
OTHER_ARGS=()
CUSTOM_TITLE=""
PROCESSED_DIR=""
USE_FZF_TEMPLATE=false
TEMPLATE_ALIAS=""
OPEN_IN_VIM="false"

COMMAND="" # Initialize COMMAND here
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -debug)
      DEBUG_MODE="true"
      shift
      ;;
    -v)
      OPEN_IN_VAULT="true"
      shift
      ;;
    -vi|-vim)
      OPEN_IN_VIM="true"
      shift
      ;;
    -template)
      USE_FZF_TEMPLATE=true
      shift
      ;;
    --title)
      if [ -n "$CUSTOM_TITLE" ]; then
        echo "Error: Only one title can be provided." >&2
        exit 1
      fi
      CUSTOM_TITLE="$2"
      shift; shift
      ;;
    _*)
      if [ -n "$CUSTOM_TITLE" ]; then
        echo "Error: Only one title can be provided." >&2
        exit 1
      fi
      CUSTOM_TITLE="${1#_}"
      shift
      ;;
    --*)
      key="${1#--}"
      if [[ -n "$2" ]] && [[ "$2" != --* ]] && [[ "$2" != '@'* ]] && [[ "$2" != '+'* ]]; then
        value="$2"
        METADATA_YAML+="${key}: \"${value}\"\n"
        shift; shift
      else
        METADATA_YAML+="${key}: true\n"
        shift
      fi
      ;;
    +*)
      KEYWORDS+=("$(echo "${1#+}" | tr '[:upper:]' '[:lower:]')")
      shift
      ;;
    @*)
      PROCESSED_DIR="${1#@}"
      shift
      ;;
    "%")
      USE_FZF_TEMPLATE=true
      shift
      ;;
    %*)
      TEMPLATE_ALIAS="${1#%}"
      shift
      ;;
    -daily|-vault|-debug|-git-setup|-sync-status|-code|-obsidian|-rename-all-untitled|-yesterday|-cmd)
      COMMAND="${1#-}" # Set COMMAND directly for known commands
      shift
      ;;
    *)
      OTHER_ARGS+=("$1")
      shift
      ;;
  esac
done

# If COMMAND was not set by a specific flag, and there are other args, and the first other arg starts with '-', it's a command.
if [ -z "$COMMAND" ] && [ ${#OTHER_ARGS[@]} -gt 0 ] && [[ "${OTHER_ARGS[0]}" == -* ]]; then
    COMMAND="${OTHER_ARGS[0]#-}"
    # Remove the command from OTHER_ARGS so it's not treated as NOTE_STRING
    OTHER_ARGS=("${OTHER_ARGS[@]:1}")
fi

# The first non-flag argument that is not a command is the note string for atomic notes
NOTE_STRING="${OTHER_ARGS[*]}"

# --- Template Selection Logic ---
# Default to the standard note template
TEMPLATE_PATH="$PROJECT_ROOT/$NOTE_TEMPLATE_PATH"

if [ "$USE_FZF_TEMPLATE" = true ] || [ "$COMMAND" == "daily" ] || [ -n "$TEMPLATE_ALIAS" ]; then
    if [ "$COMMAND" == "daily" ]; then
        TEMPLATE_ALIAS="daily"
    fi

    if [ -n "$TEMPLATE_ALIAS" ]; then
        echo "Searching for [$TEMPLATE_ALIAS] template..."
        while read -r alias path; do
        debug_log "Parsing template mapping - alias: '$alias', path: '$path'"
        if [ -n "$alias" ] && [ "$alias" == "$TEMPLATE_ALIAS" ]; then
                TEMPLATE_PATH="$PROJECT_ROOT/$path"
                break
            fi
        done <<< "$TEMPLATE_MAPPINGS"
    fi

    if [ ! -f "$TEMPLATE_PATH" ]; then
        if [ -n "$TEMPLATE_ALIAS" ]; then
            echo "Warning: Template alias '%$TEMPLATE_ALIAS' not found in config.sh." >&2
        fi
        if ! command -v fzf &> /dev/null; then
            echo "fzf is not installed. Please install it to use the template selection feature." >&2
            echo "See: https://github.com/junegunn/fzf#installation" >&2
            exit 1
        fi
        SELECTED_TEMPLATE_NAME=$(find "$PROJECT_ROOT/templates" -type f -name "*.md" | sed "s|$PROJECT_ROOT/templates/||" | fzf --prompt="Select a template: " --height=20 --border --color=dark)
        if [ -n "$SELECTED_TEMPLATE_NAME" ]; then
            TEMPLATE_PATH="$PROJECT_ROOT/templates/$SELECTED_TEMPLATE_NAME"
        else
            echo "No template selected. Aborting." >&2
            exit 1
        fi
    fi
    echo "Using [$(basename "$TEMPLATE_PATH" .md)] template from _notes/$(echo "$TEMPLATE_PATH" | sed "s|$PROJECT_ROOT/||")"
fi

case "$COMMAND" in
    cmd)
        cat "$PROJECT_ROOT/COMMANDS.md"
        exit 0
        ;;
    vault)
        if [ -n "$VAULT_PATH" ]; then
            echo "Your vault is currently set to: $VAULT_PATH"
            read -p "Do you want to change it? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                read -p "Enter the new path to your vault: " new_vault_path
                # Update the config file
                sed -i '' "s|VAULT_PATH=.*|VAULT_PATH=\"$new_vault_path\"|" "$CONFIG_FILE"
                echo "Vault path updated to: $new_vault_path"
            else
                read -p "Do you want to open the vault? (y/n) " -n 1 -r
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    "$EDITOR_CMD" "$VAULT_PATH"
                fi
            fi
        else
            echo "Your vault is not yet configured."
            read -p "Enter the path to your vault: " new_vault_path
            # Update the config file
            echo "VAULT_PATH=\"$new_vault_path\"" >> "$CONFIG_FILE"
            echo "Vault path set to: $new_vault_path"
        fi
        exit 0
        ;;
    daily)
        TODAY_DATE=$(date +'%y-%m-%d')
        # Search for any daily note for today, regardless of the title part
        EXISTING_DAILY_NOTE=$(find "${VAULT_PATH}/${DAILY_DIR}" -name "${TODAY_DATE}_*.md" -print -quit)

        if [ -n "$EXISTING_DAILY_NOTE" ]; then
            echo "Found existing daily note for today: $EXISTING_DAILY_NOTE"
            echo "Opening for editing..."
            # Use the same opening logic as the main note creation
            if [[ "$OPEN_IN_VAULT" == "true" ]]; then
                "$EDITOR_CMD" "$VAULT_PATH" --goto "$EXISTING_DAILY_NOTE":1
            else
                "$EDITOR_CMD" -g "$EXISTING_DAILY_NOTE":1
            fi
            exit 0
        fi
        # If no existing note, fall through to create a new one
        ;;
    git-setup)
        if [ ! -d "$VAULT_PATH/.git" ]; then
            git init "$VAULT_PATH"
            echo "Git repository initialized in '$VAULT_PATH'."
        else
            echo "Git repository already exists in '$VAULT_PATH'."
        fi
        exit 0
        ;;
    sync-status)
        (cd "$VAULT_PATH" && git status)
        exit 0
        ;;
    code)
        "$EDITOR_CMD" "$VAULT_PATH"
        exit 0
        ;;
    obsidian)
        open "obsidian://vault/${VAULT_NAME}"
        exit 0
        ;;
    rename-all-untitled)
        "$PROJECT_ROOT/scripts/note-sync" --rename-all
        exit 0
        ;;
    yesterday)
        YESTERDAY=$(date -v -1d +'%y-%m-%d')
        YESTERDAY_NOTE=$(find "$VAULT_PATH/$DAILY_DIR" -name "*$YESTERDAY*.md" -print -quit)

        if [ -n "$YESTERDAY_NOTE" ]; then
            "$EDITOR_CMD" "$YESTERDAY_NOTE"
        else
            LAST_DAILY_NOTE=$(find "$VAULT_PATH/$DAILY_DIR" -name "*.md" -print | sort -r | head -n 1)
            if [ -n "$LAST_DAILY_NOTE" ]; then
                echo "No daily note was captured for yesterday, opening last daily note from $(basename "$LAST_DAILY_NOTE" .md)..."
                "$EDITOR_CMD" "$LAST_DAILY_NOTE"
            else
                echo "No daily notes found."
            fi
        fi
        exit 0
        ;;
esac

# --- Main Note Creation Logic ---
if [ -z "$VAULT_PATH" ]; then echo "VAULT_PATH is not set. Please run 'note -vault'." >&2; exit 1; fi

MODE="editor"
# Atomic mode is only triggered if a note string is provided.
if [[ -n "$NOTE_STRING" ]]; then
    MODE="atomic"
fi

# Determine the subdirectory for the note
SUBDIR_FROM_TEMPLATE=""
if [ -n "$TEMPLATE_ALIAS" ]; then
    while read -r alias output_dir; do
        if [ -n "$alias" ] && [ "$alias" == "$TEMPLATE_ALIAS" ]; then
            SUBDIR_FROM_TEMPLATE="$output_dir"
            break
        fi
    done <<< "$TEMPLATE_OUTPUT_DIRS"
fi

if [ -n "$TEMPLATE_ALIAS" ] && [ -z "$SUBDIR_FROM_TEMPLATE" ]; then
    echo "Warning: No output directory mapping found for template alias '$TEMPLATE_ALIAS'. Using default inbox." >&2
fi

if [ -n "$SUBDIR_FROM_TEMPLATE" ]; then
    SUBDIR="$SUBDIR_FROM_TEMPLATE"
    STATUS="templated" # New status for notes from templates with custom output dirs
elif [[ -n "$PROCESSED_DIR" ]]; then
    SUBDIR="$PROCESSED_DIR"
    STATUS="processed"
else
    SUBDIR="00__Inbox"
    STATUS="inbox"
fi

to_kebab_case() {
    echo "$1" | iconv -t ascii//TRANSLIT | sed -E 's/[^a-zA-Z0-9]+/-/g; s/^-+|-+$//g' | tr '[:upper:]' '[:lower:]'
}

TIMESTAMP=$(date +'%y-%m-%d %H:%M:%S'); FILE_TIMESTAMP=$(date +'%y-%m-%d__%H-%M')
DAY_OF_WEEK=$(date +'%A') # Get the full weekday name
DAY_ABBREVIATION=$(date +'%a' | tr '[:lower:]' '[:upper:]') # Get 3-letter day abbreviation
TITLE=""; BODY=""; KEYWORDS_STRING=""
if [ ${#KEYWORDS[@]} -gt 0 ]; then KEYWORDS_STRING=$(IFS=,; echo "${KEYWORDS[*]}"); fi
if [ "$COMMAND" == "daily" ]; then
    TITLE="${DAY_ABBREVIATION}_daily"
elif [ "$TEMPLATE_ALIAS" == "meeting" ]; then # Set title for meeting notes
    TITLE="meeting"
    TITLE=$(echo "$NOTE_STRING" | cut -c 1-80)
    BODY="$NOTE_STRING"
else
    TITLE="untitled"
    BODY=""
fi

if [[ -n "$CUSTOM_TITLE" ]]; then
    TITLE="$CUSTOM_TITLE"
    BODY="$NOTE_STRING"
elif [[ -n "$NOTE_STRING" ]]; then
    EXTRACTED_TITLE=$(extract_title_from_note "$NOTE_STRING")
    if [[ -n "$EXTRACTED_TITLE" ]]; then
        TITLE="$EXTRACTED_TITLE"
        BODY="${NOTE_STRING#*: }"
    else
        TITLE="untitled"
        BODY="$NOTE_STRING"
    fi
fi

KEBAB_TITLE=$(to_kebab_case "$TITLE")
FILENAME_PART=""

if [ "$COMMAND" == "daily" ]; then
    FILENAME_PART="${DAY_ABBREVIATION}_daily"
elif [ "$TEMPLATE_ALIAS" == "meeting" ]; then
    FILENAME_PART="mtg"
fi

if [ -n "$FILENAME_PART" ]; then
    if [ "$COMMAND" == "daily" ]; then
        FILENAME="${FILE_TIMESTAMP}__${FILENAME_PART}.md"
    elif [ -n "$KEBAB_TITLE" ] && [ "$KEBAB_TITLE" != "$(to_kebab_case "$FILENAME_PART")" ]; then
        FILENAME="${FILE_TIMESTAMP}__${FILENAME_PART}-${KEBAB_TITLE}.md"
    else
        FILENAME="${FILE_TIMESTAMP}__${FILENAME_PART}.md"
    fi
else
    FILENAME="${FILE_TIMESTAMP}__${KEBAB_TITLE}.md"
fi
TARGET_DIR="${VAULT_PATH}/${SUBDIR}"; FILEPATH="${TARGET_DIR}/${FILENAME}"; mkdir -p "$TARGET_DIR"

get_cursor_line_number() {
    local content="$1"
    local body_line_number=$(echo "$content" | grep -n "## Body" | cut -d: -f1)
    if [ -n "$body_line_number" ]; then
        echo $((body_line_number + 1))
    else
        echo 1
    fi
}

if [ ! -f "$TEMPLATE_PATH" ]; then echo "Warning: Template not found." >&2; touch "$FILEPATH"; else
    export TIMESTAMP TITLE KEYWORDS_STRING METADATA_YAML STATUS DAY_OF_WEEK SUBDIR BODY
    CONTENT=$(cat "$TEMPLATE_PATH")
    CONTENT=$(perl -pe 's/<% timestamp %>/$ENV{TIMESTAMP}/; s/<% title %>/$ENV{TITLE}/; s/<% keywords %>/$ENV{KEYWORDS_STRING}/; s/<% metadata %>/$ENV{METADATA_YAML}/; s/<% status %>/$ENV{STATUS}/; s/<% day %>/$ENV{DAY_OF_WEEK}/; s/<% folder %>/$ENV{SUBDIR}/; s#<% body %>#$ENV{BODY}#' <<< "$CONTENT")
    printf "%b" "$CONTENT" > "$FILEPATH"
fi

cursor_line_number=$(get_cursor_line_number "$CONTENT")

echo "Note created: $FILEPATH"

if [ "$OPEN_IN_VIM" = "true" ]; then
    vim "$FILEPATH"
    exit 0
fi

debug_log "MODE is $MODE"
if [ "$MODE" == "editor" ]; then
    echo "Opening for editing..."
    if [[ "$OPEN_IN_VAULT" == "true" ]]; then 
        # echo "Executing: $EDITOR_CMD $VAULT_PATH --goto $FILEPATH:$cursor_line_number"
        debug_log "Executing command: \"$EDITOR_CMD\" \"$VAULT_PATH\" --goto \"$FILEPATH\":$cursor_line_number"
        "$EDITOR_CMD" "$VAULT_PATH" --goto "$FILEPATH":$cursor_line_number; 
    else 
        debug_log "Executing command: \"$EDITOR_CMD\" -g \"$FILEPATH\":$cursor_line_number"
        "$EDITOR_CMD" -g "$FILEPATH":$cursor_line_number; 
    fi
fi